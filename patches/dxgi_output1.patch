diff --git a/src/dxgi/dxgi_include.h b/src/dxgi/dxgi_include.h
index bef395a..1bd0400 100644
--- a/src/dxgi/dxgi_include.h
+++ b/src/dxgi/dxgi_include.h
@@ -32,4 +32,79 @@
   #define DXGI_RESOURCE_PRIORITY_NORMAL (0x78000000)
   #define DXGI_RESOURCE_PRIORITY_HIGH (0xa0000000)
   #define DXGI_RESOURCE_PRIORITY_MAXIMUM (0xc8000000)
+#endif
+
+//Some DXGI types are missing in Mingw
+#ifndef _MSC_VER
+DEFINE_GUID(IID_IDXGIOutput1, 0x00cddea8, 0x939b, 0x4b83, 0xa3,0x40, 0xa6,0x85,0x22,0x66,0x66,0xcc);
+MIDL_INTERFACE("00cddea8-939b-4b83-a340-a685226666cc")
+IDXGIOutput1 : public IDXGIOutput
+{
+    virtual HRESULT STDMETHODCALLTYPE GetDisplayModeList1(
+        DXGI_FORMAT enum_format,
+        UINT flags,
+        UINT *num_modes,
+        DXGI_MODE_DESC1 *desc) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE FindClosestMatchingMode1(
+        const DXGI_MODE_DESC1 *mode_to_match,
+        DXGI_MODE_DESC1 *closest_match,
+        IUnknown *concerned_device) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetDisplaySurfaceData1(
+        IDXGIResource *destination) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE DuplicateOutput(
+        IUnknown *device,
+        IDXGIOutputDuplication **output_duplication) = 0;
+};
+
+typedef struct DXGI_MODE_DESC1 {
+    UINT Width;
+    UINT Height;
+    DXGI_RATIONAL RefreshRate;
+    DXGI_FORMAT Format;
+    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
+    DXGI_MODE_SCALING Scaling;
+    BOOL Stereo;
+} DXGI_MODE_DESC1;
+
+DEFINE_GUID(IID_IDXGIOutputDuplication, 0x191cfac3, 0xa341, 0x470d, 0xb2,0x6e, 0xa8,0x64,0xf4,0x28,0x31,0x9c);
+MIDL_INTERFACE("191cfac3-a341-470d-b26e-a864f428319c")
+IDXGIOutputDuplication : public IDXGIObject
+{
+    virtual void STDMETHODCALLTYPE GetDesc(
+        DXGI_OUTDUPL_DESC *desc) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE AcquireNextFrame(
+        UINT timeout_in_milliseconds,
+        DXGI_OUTDUPL_FRAME_INFO *frame_info,
+        IDXGIResource **desktop_resource) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetFrameDirtyRects(
+        UINT dirty_rects_buffer_size,
+        RECT *dirty_rects_buffer,
+        UINT *dirty_rects_buffer_size_required) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetFrameMoveRects(
+        UINT move_rects_buffer_size,
+        DXGI_OUTDUPL_MOVE_RECT *move_rect_buffer,
+        UINT *move_rects_buffer_size_required) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetFramePointerShape(
+        UINT pointer_shape_buffer_size,
+        void *pointer_shape_buffer,
+        UINT *pointer_shape_buffer_size_required,
+        DXGI_OUTDUPL_POINTER_SHAPE_INFO *pointer_shape_info) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE MapDesktopSurface(
+        DXGI_MAPPED_RECT *locked_rect) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE UnMapDesktopSurface(
+        ) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE ReleaseFrame(
+        ) = 0;
+
+};
 #endif
\ No newline at end of file
diff --git a/src/dxgi/dxgi_output.cpp b/src/dxgi/dxgi_output.cpp
index c633d6d..d151a6e 100644
--- a/src/dxgi/dxgi_output.cpp
+++ b/src/dxgi/dxgi_output.cpp
@@ -47,7 +47,8 @@ namespace dxvk {
     
     if (riid == __uuidof(IUnknown)
      || riid == __uuidof(IDXGIObject)
-     || riid == __uuidof(IDXGIOutput)) {
+     || riid == __uuidof(IDXGIOutput)
+     || riid == __uuidof(IDXGIOutput1)) {
       *ppvObject = ref(this);
       return S_OK;
     }
@@ -62,7 +63,6 @@ namespace dxvk {
     return m_adapter->QueryInterface(riid, ppParent);
   }
   
-  
   HRESULT STDMETHODCALLTYPE DxgiOutput::FindClosestMatchingMode(
     const DXGI_MODE_DESC *pModeToMatch,
           DXGI_MODE_DESC *pClosestMatch,
@@ -70,6 +70,39 @@ namespace dxvk {
     if (pModeToMatch == nullptr || pClosestMatch == nullptr)
       return DXGI_ERROR_INVALID_CALL;
 
+    if (pModeToMatch->Format == DXGI_FORMAT_UNKNOWN && pConcernedDevice == nullptr)
+      return DXGI_ERROR_INVALID_CALL;
+
+    DXGI_MODE_DESC1 modeToMatch;
+    modeToMatch.Width = pModeToMatch->Width;
+    modeToMatch.Height = pModeToMatch->Height;
+    modeToMatch.RefreshRate = pModeToMatch->RefreshRate;
+    modeToMatch.Format = pModeToMatch->Format;
+    modeToMatch.ScanlineOrdering = pModeToMatch->ScanlineOrdering;
+    modeToMatch.Scaling = pModeToMatch->Scaling;
+    modeToMatch.Stereo = false;
+
+    DXGI_MODE_DESC1 closestMatch;
+
+    HRESULT hr = FindClosestMatchingMode1(&modeToMatch, &closestMatch, pConcernedDevice);
+    if (SUCCEEDED(hr)) {
+      pClosestMatch->Width = closestMatch.Width;
+      pClosestMatch->Height = closestMatch.Height;
+      pClosestMatch->RefreshRate = closestMatch.RefreshRate;
+      pClosestMatch->Format = closestMatch.Format;
+      pClosestMatch->ScanlineOrdering = closestMatch.ScanlineOrdering;
+      pClosestMatch->Scaling = closestMatch.Scaling;
+    }
+    return hr;
+  }
+  
+  HRESULT STDMETHODCALLTYPE DxgiOutput::FindClosestMatchingMode1(
+    const DXGI_MODE_DESC1 *pModeToMatch,
+          DXGI_MODE_DESC1 *pClosestMatch,
+          IUnknown       *pConcernedDevice) {
+    if (pModeToMatch == nullptr || pClosestMatch == nullptr)
+      return DXGI_ERROR_INVALID_CALL;
+
     if (pModeToMatch->Format == DXGI_FORMAT_UNKNOWN && pConcernedDevice == nullptr)
       return DXGI_ERROR_INVALID_CALL;
     
@@ -90,15 +123,15 @@ namespace dxvk {
     // List all supported modes and filter
     // out those we don't actually need
     UINT modeCount = 0;
-    GetDisplayModeList(targetFormat, DXGI_ENUM_MODES_SCALING, &modeCount, nullptr);
+    GetDisplayModeList1(targetFormat, DXGI_ENUM_MODES_SCALING, &modeCount, nullptr);
     
     if (modeCount == 0) {
       Logger::err("DXGI: FindClosestMatchingMode: No modes found");
       return DXGI_ERROR_NOT_FOUND;
     }
 
-    std::vector<DXGI_MODE_DESC> modes(modeCount);
-    GetDisplayModeList(targetFormat, DXGI_ENUM_MODES_SCALING, &modeCount, modes.data());
+    std::vector<DXGI_MODE_DESC1> modes(modeCount);
+    GetDisplayModeList1(targetFormat, DXGI_ENUM_MODES_SCALING, &modeCount, modes.data());
     
     for (auto it = modes.begin(); it != modes.end(); ) {
       bool skipMode = false;
@@ -113,6 +146,8 @@ namespace dxvk {
       // Remove modes with incorrect scaling
       if (pModeToMatch->Scaling != DXGI_MODE_SCALING_UNSPECIFIED)
         skipMode |= it->Scaling != pModeToMatch->Scaling;
+
+      skipMode |= it->Stereo != pModeToMatch->Stereo;
       
       it = skipMode ? modes.erase(it) : ++it;
     }
@@ -167,6 +202,36 @@ namespace dxvk {
           DXGI_MODE_DESC *pDesc) {
     if (pNumModes == nullptr)
       return DXGI_ERROR_INVALID_CALL;
+
+    HRESULT numHr = GetDisplayModeList1(EnumFormat, Flags, pNumModes, nullptr);
+    if (!SUCCEEDED(numHr) || pDesc == nullptr) {
+      return numHr;
+    }
+
+    DXGI_MODE_DESC1* modes = new DXGI_MODE_DESC1[*pNumModes];
+    HRESULT hr = GetDisplayModeList1(EnumFormat, Flags, pNumModes, modes);
+    if (SUCCEEDED(hr)) {
+      for (uint32_t i = 0; i < *pNumModes; i++) {
+        DXGI_MODE_DESC mode;
+        mode.Width = modes[i].Width;
+        mode.Height = modes[i].Height;
+        mode.RefreshRate = modes[i].RefreshRate;
+        mode.Format = modes[i].Format;
+        mode.ScanlineOrdering = modes[i].ScanlineOrdering;
+        mode.Scaling = modes[i].Scaling;
+        pDesc[i] = mode;
+      }
+    }
+    return hr;
+  }
+  
+  HRESULT STDMETHODCALLTYPE DxgiOutput::GetDisplayModeList1(
+          DXGI_FORMAT    EnumFormat,
+          UINT           Flags,
+          UINT           *pNumModes,
+          DXGI_MODE_DESC1 *pDesc) {
+    if (pNumModes == nullptr)
+      return DXGI_ERROR_INVALID_CALL;
     
     // Query monitor info to get the device name
     ::MONITORINFOEXW monInfo;
@@ -184,7 +249,7 @@ namespace dxvk {
     uint32_t srcModeId = 0;
     uint32_t dstModeId = 0;
     
-    std::vector<DXGI_MODE_DESC> modeList;
+    std::vector<DXGI_MODE_DESC1> modeList;
     
     while (::EnumDisplaySettingsW(monInfo.szDevice, srcModeId++, &devMode)) {
       // Skip interlaced modes altogether
@@ -196,13 +261,14 @@ namespace dxvk {
         continue;
       
       if (pDesc != nullptr) {
-        DXGI_MODE_DESC mode;
+        DXGI_MODE_DESC1 mode;
         mode.Width            = devMode.dmPelsWidth;
         mode.Height           = devMode.dmPelsHeight;
         mode.RefreshRate      = { devMode.dmDisplayFrequency * 1000, 1000 };
         mode.Format           = EnumFormat;
         mode.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE;
         mode.Scaling          = DXGI_MODE_SCALING_UNSPECIFIED;
+        mode.Stereo           = false;
         modeList.push_back(mode);
       }
       
@@ -212,15 +278,21 @@ namespace dxvk {
     // Sort display modes by width, height and refresh rate,
     // in that order. Some games rely on correct ordering.
     std::sort(modeList.begin(), modeList.end(),
-      [] (const DXGI_MODE_DESC& a, const DXGI_MODE_DESC& b) {
+      [] (const DXGI_MODE_DESC1& a, const DXGI_MODE_DESC1& b) {
         if (a.Width < b.Width) return true;
         if (a.Width > b.Width) return false;
         
         if (a.Height < b.Height) return true;
         if (a.Height > b.Height) return false;
         
-        return (a.RefreshRate.Numerator / a.RefreshRate.Denominator)
-             < (b.RefreshRate.Numerator / b.RefreshRate.Denominator);
+        if (a.RefreshRate.Numerator / a.RefreshRate.Denominator)
+             < (b.RefreshRate.Numerator / b.RefreshRate.Denominator)
+          return true;
+        if (a.RefreshRate.Numerator / a.RefreshRate.Denominator)
+            < (b.RefreshRate.Numerator / b.RefreshRate.Denominator)
+          return false;
+
+        return a.Stereo && !b.Stereo;
       });
     
     // If requested, write out the first set of display
@@ -238,6 +310,11 @@ namespace dxvk {
   }
   
   
+  HRESULT STDMETHODCALLTYPE DxgiOutput::GetDisplaySurfaceData1(IDXGIResource* pDestination) {
+    Logger::err("DxgiOutput::GetDisplaySurfaceData: Not implemented");
+    return E_NOTIMPL;
+  }
+  
   HRESULT STDMETHODCALLTYPE DxgiOutput::GetDisplaySurfaceData(IDXGISurface* pDestination) {
     Logger::err("DxgiOutput::GetDisplaySurfaceData: Not implemented");
     return E_NOTIMPL;
@@ -378,6 +455,14 @@ namespace dxvk {
     return status == DISP_CHANGE_SUCCESSFUL ? S_OK : DXGI_ERROR_NOT_CURRENTLY_AVAILABLE;;
   }
   
+
+  HRESULT DxgiOutput::DuplicateOutput(
+        IUnknown               *pDevice,
+        IDXGIOutputDuplication **ppOutputDuplication) {
+    Logger::warn("DxgiOutput1::DuplicateOutput: Stub");
+    return S_OK;
+  }
+  
   
   uint32_t DxgiOutput::GetFormatBpp(DXGI_FORMAT Format) const {
     DXGI_VK_FORMAT_INFO formatInfo = m_adapter->LookupFormat(Format, DXGI_VK_FORMAT_MODE_ANY);
diff --git a/src/dxgi/dxgi_output.h b/src/dxgi/dxgi_output.h
index 4b23032..36e0fdd 100644
--- a/src/dxgi/dxgi_output.h
+++ b/src/dxgi/dxgi_output.h
@@ -19,7 +19,7 @@ namespace dxvk {
   };
   
   
-  class DxgiOutput : public DxgiObject<IDXGIOutput> {
+  class DxgiOutput : public DxgiObject<IDXGIOutput1> {
     
   public:
     
@@ -42,6 +42,11 @@ namespace dxvk {
             DXGI_MODE_DESC*       pClosestMatch,
             IUnknown*             pConcernedDevice) final;
     
+    HRESULT STDMETHODCALLTYPE FindClosestMatchingMode1(
+      const DXGI_MODE_DESC1*       pModeToMatch,
+            DXGI_MODE_DESC1*       pClosestMatch,
+            IUnknown*             pConcernedDevice) final;
+    
     HRESULT STDMETHODCALLTYPE GetDesc(
             DXGI_OUTPUT_DESC*     pDesc) final;
     
@@ -51,9 +56,18 @@ namespace dxvk {
             UINT*                 pNumModes,
             DXGI_MODE_DESC*       pDesc) final;
     
+    HRESULT STDMETHODCALLTYPE GetDisplayModeList1(
+            DXGI_FORMAT           EnumFormat,
+            UINT                  Flags,
+            UINT*                 pNumModes,
+            DXGI_MODE_DESC1*       pDesc) final;
+    
     HRESULT STDMETHODCALLTYPE GetDisplaySurfaceData(
             IDXGISurface*         pDestination) final;
     
+    HRESULT STDMETHODCALLTYPE GetDisplaySurfaceData1(
+            IDXGIResource*         pDestination) final;
+    
     HRESULT STDMETHODCALLTYPE GetFrameStatistics(
             DXGI_FRAME_STATISTICS* pStats) final;
     
@@ -83,6 +97,10 @@ namespace dxvk {
     
     HRESULT SetDisplayMode(
       const DXGI_MODE_DESC*       pMode);
+
+    HRESULT DuplicateOutput(
+          IUnknown               *pDevice,
+          IDXGIOutputDuplication **ppOutputDuplication) final;
     
   private:
     
